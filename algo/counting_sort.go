package algo

// 计数排序
// 时间复杂度：O(n)
// 非原址排序
// 稳定性：稳定排序（两个相同元素在输入数组和输出数组中的次序一致）
// 思想：计数排序属于非比较排序，是通过运算排序的，能够做到时间复杂度 O(n)（通过决策树可以证明所有比较排序的时间下限是 nlgn）
// 		要求被排序元素是0 - n 的整数，n 是一个确切的整数数值（不能有负数，因为需要用数组下标表示这些数值，如果有负数则需要转成非负数）
//		通过大小为 n 的数组 c 的下标表示这些数值，c 的值表示这些数出现的（最后）位置，然后从右往左将元素放到相应位置
// 计数排序适用于非负整数、重复率较高、最大值较小的数组排序（如年龄、分数等）
func CountingSort(lst []int, max int) []int {
	// 如果外面不能确定 lst 中的最大值，则由内部计算
	if max < 0 {
		for i := 0; i < len(lst); i++ {
			if max < lst[i] {
				max = lst[i]
			}
		}
	}

	// 创建一个 max + 1 大小的切片，其值初始化为 0
	c := make([]int, max + 1)

	// 遍历 lst，计算每个元素出现的次数
	for i := 0; i < len(lst); i++ {
		c[lst[i]] += 1
	}

	// 计算元素位置：后面元素 x 的左位置等于前面元素位置+1，右位置等于前面元素位置+m，m 为 x 出现的次数
	for i := 1; i <= max; i++ {
		c[i] += c[i - 1]
	}

	rst := make([]int, len(lst))
	// 从右往左遍历 lst 元素，将其放入正确的位置
	// 注意必须从右往左，因为 c 中记录的是元素最右边的位置（如果有多个元素的话），这样才能保证排序的稳定性
	for i := len(lst) - 1; i >= 0; i-- {
		rst[c[lst[i]] - 1] = lst[i]
		// 完成一个了，需要从里面减去，接下来的（左边的）该元素会紧贴着此位置左边的位置放
		c[lst[i]] -= 1
	}

	return rst
}